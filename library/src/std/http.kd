import std.sys
import std.string
import std.collections

use std.sys.Fd
use std.string.String
use std.collections.Vector

// ====== Minimal HTTP request/response types ======

pub struct Request {
    method: String,
    path: String,
    version: String,
    headers: [u8],
    body: [u8],
}

pub struct Response {
    conn: Fd,
    close_conn: bool,
}

impl Response {
    pub fn new(conn: Fd, close_conn: bool): mut Response {
        return Response { conn: conn, close_conn: close_conn }
    }

    pub fn send_bytes(mut self, status: i32, body: [u8]) {
        write_status_line(self.conn, status)
        if self.close_conn {
            std.sys.write(self.conn, b"Connection: close\r\n")
        }
        write_content_length(self.conn, body.len())
        std.sys.write(self.conn, b"\r\n")
        std.sys.write(self.conn, body)
    }

    pub fn send_string(mut self, status: i32, text: str) {
        // Note: assumes ASCII
        let mut bytes = [0; 2048]
        let mut i = 0
        while i < text.len() && i < bytes.len() {
            bytes[i] = text[i] as u8
            i += 1
        }
        self.send_bytes(status, bytes[0:i])
    }
}

pub fn parse_content_length(header: [u8]): i32 {
    let key = b"Content-Length: "
    let idx = std.sys.find_subslice(header, key)
    if idx < 0 {
        return 0
    }

    let mut i = (idx as u64) + key.len()
    let mut val: i32 = 0
    while i < header.len() {
        let b = header[i]
        if b == b'\r' {
            break
        }
        if b < b'0' || b > b'9' {
            return -1
        }
        val = (val * 10) + ((b - b'0') as i32)
        i += 1
    }
    return val
}

fn write_content_length(conn: Fd, len: u64) {
    let prefix = b"Content-Length: "
    std.sys.write(conn, prefix)

    let mut digits = [0; 20]
    let mut d = 0
    let mut n = len
    if n == 0 {
        digits[0] = b'0'
        d = 1
    } else {
        while n > 0 {
            let digit = (n % 10) as u8
            digits[d] = b'0' + digit
            d += 1
            n = n / 10
        }
    }

    let mut j = d
    loop {
        if j == 0 {
            break
        }
        j -= 1
        let mut one = [0; 1]
        one[0] = digits[j]
        std.sys.write(conn, one)
    }

    std.sys.write(conn, b"\r\n")
}

pub fn write_status_line(conn: Fd, status: i32) {
    if status == 200 {
        std.sys.write(conn, b"HTTP/1.1 200 OK\r\n")
    } else if status == 404 {
        std.sys.write(conn, b"HTTP/1.1 404 Not Found\r\n")
    } else if status == 400 {
        std.sys.write(conn, b"HTTP/1.1 400 Bad Request\r\n")
    } else if status == 413 {
        std.sys.write(conn, b"HTTP/1.1 413 Payload Too Large\r\n")
    } else {
        std.sys.write(conn, b"HTTP/1.1 500 Internal Server Error\r\n")
    }
}

pub fn write_text_response(conn: Fd, close_conn: bool, status: i32, body: [u8]) {
    write_status_line(conn, status)
    if close_conn {
        std.sys.write(conn, b"Connection: close\r\n")
    }
    write_content_length(conn, body.len())
    std.sys.write(conn, b"\r\n")
    std.sys.write(conn, body)
}

pub fn write_bytes_response(conn: Fd, close_conn: bool, status: i32, body: [u8]) {
    write_text_response(conn, close_conn, status, body)
}

// ====== Routing ======

pub type Handler = fn(mut Request, mut Response)

struct Route {
    method: String,
    path: String,
    handler: Handler,
}

pub struct App {
    routes: Vector<Route>,
}

impl App {
    pub fn new(): mut App {
        return App { routes: Vector<Route>::new() }
    }

    pub fn get(mut self, path: str, handler: Handler) {
        self.add_route("GET", path, handler)
    }

    pub fn post(mut self, path: str, handler: Handler) {
        self.add_route("POST", path, handler)
    }

    fn add_route(mut self, method: str, path: str, handler: Handler) {
        let m = String::from(method)
        let p = String::from(path)
        let route = Route { method: m, path: p, handler: handler }
        self.routes.push(route)
    }

    pub fn dispatch(self, req: mut Request, res: mut Response): bool {
        let mut i = 0
        while i < self.routes.len() {
            let r = self.routes.at(i).unwrap()
            if r.method.as_str() == req.method.as_str() && r.path.as_str() == req.path.as_str() {
                let h = r.handler
                h(req, res)
                return true
            }
            i += 1
        }
        return false
    }
}
