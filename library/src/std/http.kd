import std.sys
import std.string
import std.collections
import std.io
import std.option

use std.sys.Fd
use std.string.String
use std.collections.Vector
use std.option.Option

// ====== Minimal HTTP request/response types ======

pub enum Status {
    Ok, // 200
    NotFound, // 404
    BadRequest, // 400
    PayloadTooLarge, // 413
    InternalServerError, // 500
}

pub struct Request {
    method: String,
    path: String,
    query: String,
    version: String,
    headers: [u8],
    body: [u8],
}

impl Request {
    // Returns the value of the query parameter `name` (e.g. ?n=1000 -> get_query_param("n") -> Some("1000")).
    pub fn get_query_param(self, name: str): Option<String> {
        return find_query_param_value(self.query, name)
    }
}

pub struct Response {
    conn: Fd,
    close_conn: bool,
    status: Status,
}

impl Response {
    pub fn new(conn: Fd, close_conn: bool): mut Response {
        return Response { conn, close_conn, status: Status::Ok }
    }

    pub fn status(mut self, code: Status): mut Response {
        self.status = code
        return self
    }

    pub fn send_bytes(mut self, body: [u8]) {
        write_status_line(self.conn, self.status)
        if self.close_conn {
            std.sys.write(self.conn, b"Connection: close\r\n")
        }
        write_content_length(self.conn, body.len())
        std.sys.write(self.conn, b"\r\n")
        std.sys.write(self.conn, body)
    }

    pub fn send_string(mut self, text: str) {
        // Note: assumes ASCII
        let mut bytes = [0; 2048]
        let mut i = 0
        while i < text.len() && i < bytes.len() {
            bytes[i] = text[i] as u8
            i += 1
        }
        self.send_bytes(bytes[0:i])
    }
}

// Splits the request target (e.g. "/primes?n=1000") into path and query string.
// Path is the part before '?'; query is the part after '?' or empty if no '?'.
fn split_path_query(target: String): (String, String) {
    let mut i = 0

    let mut path = String::new()
    while i < target.len() {
        let c = target.at(i)
        match c {
            Option::Some(ch) => {
                if ch == '?' {
                    i += 1
                    break
                }
                path.push(ch)
                i += 1
            },
            Option::None => break
        }
    }

    // Remainder after '?' is the query string (e.g. "n=1000&foo=bar")
    let mut query = String::new()
    while i < target.len() {
        let c = target.at(i)
        match c {
            Option::Some(ch) => {
                query.push(ch)
                i += 1
            },
            Option::None => break
        }
    }

    return (path, query)
}

fn find_char_from(s: String, start: u64, target: char): u64 {
    let mut i = start
    while i < s.len() {
        match s.at(i) {
            Option::Some(ch) => {
                if ch == target {
                    return i
                }
                i += 1
            },
            Option::None => break
        }
    }
    return s.len()
}

// Parses query string "key1=val1&key2=val2" and returns the value for the given name.
// We scan each '&'-separated segment, then split the segment by '='.
fn find_query_param_value(query: String, name: str): Option<String> {
    let mut seg_start = 0
    while seg_start <= query.len() {
        let seg_end = find_char_from(query, seg_start, '&')
        let eq_pos = find_char_from(query, seg_start, '=')

        // A valid key-value pair is "key=value" where '=' exists inside the segment.
        if eq_pos < seg_end {
            let key = query.slice(seg_start, eq_pos)
            if key.as_str() == name {
                return Option<String>::Some(query.slice(eq_pos + 1, seg_end))
            }
        }

        if seg_end >= query.len() {
            break
        }
        seg_start = seg_end + 1
    }
    return Option<String>::None
}

pub fn parse_content_length(header: [u8]): i32 {
    let key = b"Content-Length: "
    let idx = std.sys.find_subslice(header, key)
    if idx < 0 {
        return 0
    }

    let mut i = (idx as u64) + key.len()
    let mut val: i32 = 0
    while i < header.len() {
        let b = header[i]
        if b == b'\r' {
            break
        }
        if b < b'0' || b > b'9' {
            return -1
        }
        val = (val * 10) + ((b - b'0') as i32)
        i += 1
    }
    return val
}

fn write_content_length(conn: Fd, len: u64) {
    let prefix = b"Content-Length: "
    std.sys.write(conn, prefix)

    let mut digits = [0; 20]
    let mut d = 0
    let mut n = len
    if n == 0 {
        digits[0] = b'0'
        d = 1
    } else {
        while n > 0 {
            let digit = (n % 10) as u8
            digits[d] = b'0' + digit
            d += 1
            n = n / 10
        }
    }

    let mut j = d
    loop {
        if j == 0 {
            break
        }
        j -= 1
        let mut one = [0; 1]
        one[0] = digits[j]
        std.sys.write(conn, one)
    }

    std.sys.write(conn, b"\r\n")
}

pub fn write_status_line(conn: Fd, status: Status) {
    match status {
        Status::Ok => std.sys.write(conn, b"HTTP/1.1 200 OK\r\n"),
        Status::NotFound => std.sys.write(conn, b"HTTP/1.1 404 Not Found\r\n"),
        Status::BadRequest => std.sys.write(conn, b"HTTP/1.1 400 Bad Request\r\n"),
        Status::PayloadTooLarge => std.sys.write(conn, b"HTTP/1.1 413 Payload Too Large\r\n"),
        Status::InternalServerError => std.sys.write(conn, b"HTTP/1.1 500 Internal Server Error\r\n"),
    }
}

pub fn write_text_response(conn: Fd, close_conn: bool, status: Status, body: [u8]) {
    write_status_line(conn, status)
    if close_conn {
        std.sys.write(conn, b"Connection: close\r\n")
    }
    write_content_length(conn, body.len())
    std.sys.write(conn, b"\r\n")
    std.sys.write(conn, body)
}

pub fn write_bytes_response(conn: Fd, close_conn: bool, status: Status, body: [u8]) {
    write_text_response(conn, close_conn, status, body)
}

// ====== Routing ======

pub type Handler = fn(mut Request, mut Response)

struct Route {
    method: String,
    path: String,
    handler: Handler,
}

pub struct App {
    routes: Vector<Route>,
}

impl App {
    pub fn new(): mut App {
        return App { routes: Vector<Route>::new() }
    }

    pub fn get(mut self, path: str, handler: Handler) {
        self.add_route("GET", path, handler)
    }

    pub fn post(mut self, path: str, handler: Handler) {
        self.add_route("POST", path, handler)
    }

    fn add_route(mut self, method: str, path: str, handler: Handler) {
        let route = Route { method: String::from(method), path: String::from(path), handler }
        self.routes.push(route)
    }

    pub fn dispatch(self, req: mut Request, res: mut Response): bool {
        let mut i = 0
        while i < self.routes.len() {
            let r = self.routes.at(i).unwrap()
            if r.method.as_str() == req.method.as_str() && r.path.as_str() == req.path.as_str() {
                let h = r.handler
                h(req, res)
                return true
            }
            i += 1
        }
        return false
    }

    pub fn listen(self, ip: str = "0.0.0.0", port: u16) {
        serve_tcp4(self, ip, port)
    }
}

// ====== Connection handling / server ======

fn handle_conn(conn: Fd, app: App) {
    loop {
        let mut buf = [0; 8192]

        let n = std.sys.read_until(conn, buf, b"\r\n\r\n")
        if n == 0 {
            break
        }

        let header_end = std.sys.find_subslice(buf[0:n], b"\r\n\r\n")
        if header_end < 0 {
            write_text_response(conn, true, Status::BadRequest, b"")
            break
        }

        let header_len = header_end + 4
        let header = buf[0:header_len]

        let (method, target, version) = std.sys.parse_request_line(header)
        // Split target into path (for routing) and query string (for get_query_param)
        let (path, query) = split_path_query(target)

        let content_length = parse_content_length(header)
        if content_length < 0 {
            write_text_response(conn, true, Status::BadRequest, b"")
            break
        }

        let mut body = [0; 4096]
        let mut body_len = 0
        if content_length > 0 {
            if content_length as u64 > body.len() {
                write_text_response(conn, true, Status::PayloadTooLarge, b"")
                break
            }
            body_len = std.sys.read_exact(conn, body, content_length as u64)
        }

        let want_close = std.sys.header_has_connection_close(header, version.as_str())

        let mut req = Request {
            method,
            path,
            query,
            version,
            headers: header,
            body: body[0:body_len],
        }
        let mut res = Response::new(conn, want_close)

        let handled = app.dispatch(req, res)
        if !handled {
            write_text_response(conn, want_close, Status::NotFound, b"")
        }

        if want_close {
            break
        }
    }

    std.sys.close(conn)
}

pub fn serve_tcp4(app: App, ip: str, port: u16) {
    let backlog = std.sys.somaxconn()
    let fd = std.sys.socket_tcp4()
    std.sys.bind_ipv4(fd, ip, port)
    std.sys.listen(fd, backlog)

    loop {
        let conn = std.sys.accept(fd)
        spawn handle_conn(conn, app)
    }
}
