import std.io
import std.ffi.sys
import std.string

use std.string.String

pub extern "C" fn abort()

use std.ffi.sys.*

pub struct Fd {
    raw: i32,
}

impl Fd {
    pub fn new(fd: i32): Fd {
        return Fd { raw: fd }
    }
}

pub fn socket_tcp4(): Fd {
    let fd = __sys_socket_tcp4()
    if fd < 0 {
        abort()
    }
    return Fd::new(fd)
}

pub fn set_reuseaddr(fd: Fd) {
    let r = __sys_set_reuseaddr(fd.raw)
    if r < 0 {
        abort()
    }
}

pub fn bind_ipv4(fd: Fd, ip: str, port: u16) {
    let r = __sys_bind_ipv4(fd.raw, ip.as_ptr(), port)
    if r < 0 {
        abort()
    }
}

pub fn listen(fd: Fd, backlog: i32) {
    let r = __sys_listen(fd.raw, backlog)
    if r < 0 {
        abort()
    }
}

pub fn accept(fd: Fd): Fd {
    let c = __sys_accept(fd.raw)
    if c < 0 {
        abort()
    }
    return Fd::new(c)
}

pub fn close(fd: Fd) {
    let r = __sys_close(fd.raw)
    if r < 0 {
        abort()
    }
}

// ===== I/O =====

pub fn read(fd: Fd, buf: mut [u8]): u64 {
    let n = __sys_read(fd.raw, buf.as_ptr() as *i8, buf.len())

    if n < 0 {
        abort()
    }

    return n as u64
}

pub fn write(fd: Fd, buf: [u8]): u64 {
    return write_all(fd, buf)
}

fn write_all(fd: Fd, buf: [u8]): u64 {
    let mut off = 0
    let total = buf.len()

    loop {
        if off >= total {
            break
        }

        let ptr = __ptr_add(buf.as_ptr(), off)
        let rem = total - off

        let n = __sys_write(fd.raw, ptr as *i8, rem)

        if n < 0 {
            abort()
        }

        if n == 0 {
            abort()
        }

        off += n as u64
    }

    return total
}

pub fn read_until(fd: Fd, buf: mut [u8], delim: [u8]): u64 {
    let mut filled = 0

    loop {
        if filled >= buf.len() {
            abort()
        }

        let mut tail = buf[filled:buf.len()]

        let n = std.sys.read(fd, tail)
        if n <= 0 {
            abort()
        }

        filled += n

        let p = find_subslice(buf[0:filled], delim)
        if p >= 0 {
            return (p as u64) + delim.len()
        }
    }

    __unreachable()
}

pub fn find_subslice(haystack: [u8], needle: [u8]): i32 {
    let hlen = haystack.len()
    let nlen = needle.len()

    if hlen < nlen {
        return -1
    }

    let mut i = 0

    loop {
        if i > hlen - nlen {
            return -1
        }

        let mut j = 0
        let mut ok = true

        loop {
            if j >= nlen {
                break
            }

            if haystack[i + j] != needle[j] {
                ok = false
                break
            }
            j += 1
        }

        if ok {
            return i as i32
        }

        i += 1
    }

    return -1
}

pub fn parse_request_line(header: [u8]): (String, String, String) {
    let i = find_subslice(header, b"\r\n")
    if i < 0 {
        abort() // 400
    }

    let line = header[0:i] // "GET /path HTTP/1.1"
    return split3_spaces(line)
}

fn split3_spaces(line: [u8]): (String, String, String) {
    let sp1 = find_byte(line, b' ')
    if sp1 < 0 {
        abort()
    }

    let rest = line[(sp1 + 1):line.len()]

    let sp2 = find_byte(rest, b' ')
    if sp2 < 0 {
        abort()
    }

    let method_bytes = line[0:sp1]
    let target_bytes = rest[0:sp2]
    let ver_bytes    = rest[(sp2 + 1):rest.len()]

    let method = String::from_bytes(method_bytes)
    let target = String::from_bytes(target_bytes)
    let ver    = String::from_bytes(ver_bytes)

    return (method, target, ver)
}

fn find_byte(buf: [u8], b: u8): i32 {
    let mut i = 0
    loop {
        if i == buf.len() {
            break
        }

        if buf[i] == b {
            return i as i32
        }
        i += 1
    }
    return -1
}
