import std.ffi.sys
import std.string

use std.string.String

use std.ffi.sys.*

pub struct Fd {
    raw: i32,
}

impl Fd {
    pub fn new(fd: i32): Fd {
        return Fd { raw: fd }
    }
}

pub fn socket_tcp4(): Fd {
    let fd = __sys_socket_tcp4()
    if fd < 0 {
        panic("socket_tcp4 failed")
    }
    return Fd::new(fd)
}

pub fn set_reuseaddr(fd: Fd) {
    let r = __sys_set_reuseaddr(fd.raw)
    if r < 0 {
        panic("set_reuseaddr failed")
    }
}

pub fn bind_ipv4(fd: Fd, ip: str, port: u16) {
    let r = __sys_bind_ipv4(fd.raw, ip.as_ptr(), port)
    if r < 0 {
        panic("bind_ipv4 failed")
    }
}

pub fn listen(fd: Fd, backlog: i32) {
    let r = __sys_listen(fd.raw, backlog)
    if r < 0 {
        panic("listen failed")
    }
}

pub fn accept(fd: Fd): Fd {
    let c = __sys_accept(fd.raw)
    if c < 0 {
        panic("accept failed")
    }
    return Fd::new(c)
}

pub fn close(fd: Fd) {
    let r = __sys_close(fd.raw)
    if r < 0 {
        panic("close failed")
    }
}

// ===== I/O =====

pub fn read(fd: Fd, buf: mut [u8]): u64 {
    let n = __sys_read(fd.raw, buf.as_ptr() as *i8, buf.len())

    if n < 0 {
        panic("read failed")
    }

    return n as u64
}

pub fn write(fd: Fd, buf: [u8]): u64 {
    return write_all(fd, buf)
}

fn write_all(fd: Fd, buf: [u8]): u64 {
    let mut off = 0
    let total = buf.len()

    while off < total {
        let ptr = __ptr_add(buf.as_ptr(), off)
        let rem = total - off

        let n = __sys_write(fd.raw, ptr as *i8, rem)

        if n < 0 {
            panic("write failed")
        }

        if n == 0 {
            panic("write returned 0")
        }

        off += n as u64
    }

    return total
}

pub fn read_until(fd: Fd, buf: mut [u8], delim: [u8]): u64 {
    let mut filled = 0

    loop {
        if filled >= buf.len() {
            panic("read_until: buffer full")
        }

        let mut tail = buf[filled:buf.len()]

        let n = std.sys.read(fd, tail)
        if n < 0 {
            panic("read_until: read failed")
        }
        if n == 0 {
            // EOF: caller decides how to handle closed connection
            return 0
        }

        filled += n

        let p = find_subslice(buf[0:filled], delim)
        if p >= 0 {
            return (p as u64) + delim.len()
        }
    }

    __unreachable()
}

pub fn find_subslice(haystack: [u8], needle: [u8]): i32 {
    let hlen = haystack.len()
    let nlen = needle.len()

    if hlen < nlen {
        return -1
    }

    let mut i = 0

    while i <= hlen - nlen {
        let mut j = 0
        let mut ok = true

        while j < nlen {
            if haystack[i + j] != needle[j] {
                ok = false
                break
            }
            j += 1
        }

        if ok {
            return i as i32
        }

        i += 1
    }

    return -1
}

pub fn parse_request_line(header: [u8]): (String, String, String) {
    let i = find_subslice(header, b"\r\n")
    if i < 0 {
        panic("parse_request_line: missing CRLF")
    }

    let line = header[0:i] // "GET /path HTTP/1.1"
    return split3_spaces(line)
}

fn split3_spaces(line: [u8]): (String, String, String) {
    let sp1 = find_byte(line, b' ')
    if sp1 < 0 {
        panic("split3_spaces: missing first space")
    }

    let rest = line[(sp1 + 1):line.len()]

    let sp2 = find_byte(rest, b' ')
    if sp2 < 0 {
        panic("split3_spaces: missing second space")
    }

    let method_bytes = line[0:sp1]
    let target_bytes = rest[0:sp2]
    let ver_bytes    = rest[(sp2 + 1):rest.len()]

    let method = String::from_bytes(method_bytes)
    let target = String::from_bytes(target_bytes)
    let ver    = String::from_bytes(ver_bytes)

    return (method, target, ver)
}

fn find_byte(buf: [u8], b: u8): i32 {
    let mut i = 0
    while i < buf.len() {
        if buf[i] == b {
            return i as i32
        }
        i += 1
    }
    return -1
}

pub fn header_has_connection_close(header: [u8], version: str): bool {
    if find_subslice(header, b"Connection: close") >= 0 {
        return true
    }

    // HTTP/1.0 is close by default
    if version == "HTTP/1.0" {
        if find_subslice(header, b"Connection: keep-alive") >= 0 {
            return false
        }
        return true
    }

    // HTTP/1.1 is keep-alive by default
    return false
}
