import std.collections
import std.option

use std.collections.Vector
use std.option.Option

pub struct String {
    chars: Vector<char>,
}

impl String {
    pub fn new(): mut String {
        return String { chars: Vector<char>::new() }
    }

    pub fn from(s: str): mut String {
        let mut chars = Vector<char>::new()

        let mut i = 0
        while i < s.len() {
            chars.push(s[i])
            i += 1
        }

        return String { chars }
    }

    pub fn from_bytes(bytes: [u8]): String {
        let mut chars = Vector<char>::new()

        let mut i = 0
        while i < bytes.len() {
            chars.push(bytes[i] as char)
            i += 1
        }

        return String { chars }
    }

    pub fn as_ptr(self): *char {
        return self.chars.as_ptr()
    }

    pub fn len(self): u64 {
        return self.chars.len()
    }

    pub fn as_str(self): str {
        return __str(self.as_ptr(), self.len())
    }

    pub fn at(self, idx: u64): Option<char> {
        return self.chars.at(idx)
    }

    pub fn push(mut self, ch: char) {
        self.chars.push(ch)
    }

    // Returns substring from start (inclusive) to end (exclusive). Like [start:end] slice syntax.
    // Returns empty string if start >= end or start >= len.
    pub fn slice(self, start: u64, end: u64): String {
        let chars = self.chars.as_slice()
        let len = chars.len()
        let safe_start = if start > len { len } else { start }
        let safe_end = if end > len { len } else { end }
        if safe_start >= safe_end {
            return String::new()
        }

        return String { chars: Vector<char>::from_slice(chars[safe_start:safe_end]) }
    }
}
