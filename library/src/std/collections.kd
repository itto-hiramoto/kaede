import std.option
import std.ffi.mem

use std.option.Option
use std.ffi.mem.__mem_alloc
use std.ffi.mem.__mem_realloc

pub struct Vector<T> {
    ptr: *T,
    len: u64,
    capacity: u64,
}

impl<T> Vector<T> {
    pub fn new(): mut Vector<T> {
        return Vector<T> { ptr: __mem_alloc(0) as *T, len: 0, capacity: 0 }
    }

    pub fn as_ptr(self): *T {
        return self.ptr
    }

    pub fn as_slice(self): [T] {
        return __slice_from_raw_parts(self.ptr, self.len)
    }

    pub fn len(self): u64 {
        return self.len
    }

    pub fn capacity(self): u64 {
        return self.capacity
    }

    fn ensure_capacity(mut self, elem_size: u64) {
        if self.capacity == 0 {
            self.capacity = 4
            let new_size = elem_size * self.capacity
            self.ptr = __mem_alloc(new_size) as *T
            return
        }

        if self.len < self.capacity {
            return
        }

        let new_capacity = self.capacity * 2
        let new_size = elem_size * new_capacity
        self.ptr = __mem_realloc(self.ptr as *i8, new_size) as *T
        self.capacity = new_capacity
    }

    pub fn push(mut self, elem: T) {
        let elem_size = __sizeof(elem)

        self.ensure_capacity(elem_size)

        self.ptr[self.len] = elem
        self.len += 1
    }

    pub fn pop(mut self): Option<T> {
        if self.len == 0 {
            return Option<T>::None
        }

        self.len -= 1
        return Option<T>::Some(self.ptr[self.len])
    }

    pub fn at(self, idx: u64): Option<T> {
        if idx >= self.len {
            return Option<T>::None
        }

        return Option<T>::Some(self.ptr[idx])
    }

    pub fn from_slice(s: [T]): mut Vector<T> {
        let mut v = Vector<T>::new()
        let mut i = 0
        while i < s.len() {
            v.push(s[i])
            i += 1
        }
        return v
    }
}
